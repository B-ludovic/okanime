generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String   @id @default(uuid())
  username        String   @unique
  email           String   @unique
  password        String
  role            Role     @default(USER)
  isSuperAdmin    Boolean  @default(false)
  dateInscription DateTime @default(now())
  avatar          String?
  
  bibliotheque              Bibliotheque[]
  avis                      Avis[]
  animesAjoutes             Anime[]                    @relation("UserAddedAnime")
  emailVerificationTokens   EmailVerificationToken[]
  passwordResetTokens       PasswordResetToken[]
  
  @@map("users")
}

enum Role {
  VISITEUR
  USER
  ADMIN
}

model Anime {
  id                String            @id @default(uuid())
  malId             Int?              @unique // MyAnimeList ID depuis Jikan
  titreVf           String
  synopsis          String            @db.Text
  anneeDebut        Int
  studio            String?
  posterUrl         String?
  noteMoyenne       Float?            @default(0)
  statutModeration  StatutModeration  @default(EN_ATTENTE)
  verifie           Boolean           @default(false) // Vérifié définitivement par un admin
  dateAjout         DateTime          @default(now())
  
  userIdAjout       String
  userAjout         User              @relation("UserAddedAnime", fields: [userIdAjout], references: [id])
  
  saisons           Saison[]
  avis              Avis[]
  genres            AnimeGenre[]
  apiImports        ApiImportLog[]
  
  @@map("animes")
}

enum StatutModeration {
  EN_ATTENTE
  VALIDE
  REFUSE
}

model Saison {
  id             String       @id @default(uuid())
  animeId        String
  numeroSaison   Int
  titreSaison    String?
  resume         String?      @db.Text
  nombreEpisodes Int
  annee          Int
  statut         StatutSaison @default(TERMINE)
  
  anime          Anime        @relation(fields: [animeId], references: [id], onDelete: Cascade)
  bibliotheque   Bibliotheque[]
  
  @@map("saisons")
}

enum StatutSaison {
  EN_COURS
  TERMINE
}

model Genre {
  id     String       @id @default(uuid())
  nom    String       @unique
  
  animes AnimeGenre[]
  
  @@map("genres")
}

model AnimeGenre {
  animeId String
  genreId String
  
  anime   Anime  @relation(fields: [animeId], references: [id], onDelete: Cascade)
  genre   Genre  @relation(fields: [genreId], references: [id], onDelete: Cascade)
  
  @@id([animeId, genreId])
  @@map("anime_genres")
}

model Bibliotheque {
  id                  String              @id @default(uuid())
  userId              String
  saisonId            String
  statut              StatutBibliotheque  @default(A_VOIR)
  progressionEpisodes Int                 @default(0)
  dateAjout           DateTime            @default(now())
  
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  saison              Saison              @relation(fields: [saisonId], references: [id], onDelete: Cascade)
  
  @@unique([userId, saisonId])
  @@map("bibliotheques")
}

enum StatutBibliotheque {
  A_VOIR
  EN_COURS
  VU
  FAVORI
}

model Avis {
  id               String   @id @default(uuid())
  userId           String
  animeId          String
  note             Int      @default(0)
  commentaire      String?  @db.Text
  dateCreation     DateTime @default(now())
  dateModification DateTime @updatedAt
  
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  anime            Anime    @relation(fields: [animeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, animeId])
  @@index([animeId]) // AJOUT : Index pour performance
  @@index([userId])  // AJOUT : Index pour performance

  @@map("avis")
}

model ApiImportLog {
  id         String   @id @default(uuid())
  animeId    String
  sourceApi  String
  dateImport DateTime @default(now())
  
  anime      Anime    @relation(fields: [animeId], references: [id], onDelete: Cascade)
  
  @@map("api_import_logs")
}

model Message {
  id            String   @id @default(uuid())
  nom           String
  email         String
  sujet         String
  message       String   @db.Text
  lu            Boolean  @default(false)
  dateCreation  DateTime @default(now())
  
  @@map("messages")
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("email_verification_tokens")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("password_reset_tokens")
}